---
title: check result
format: html
execute:
  cache: false
  echo: true
---


# where did the bug come from?

The problem is the original SpliceJunctionClassifier.py expects input count coordinates be exactly like leafcutter1, which is not BED or VCF format. All procedures prior to that step in leafcutter2 produces BED formatted coordinates. 


**Fix:**

In the SpliceJunctionClassifer function, convert perind.counts.gz coordinates into leafcutter1, run through procedure, then convert back to BED formatted before writing any output. All outputs will be back to BED format.



BED | VCF | Leafcutter1 | Leafcutter2
--- | --- | --- | ---
chr1:100-200 | chr1:101-200 | chr1:100-201| chr1:100-200

- Regtools extracted junctions are in BED12 format which uses the same BED format (0-based left closed, right open). 
- Leafcutter2 follows exact same format as BED
- Leafcutter1 converts from BED (chrom, start, end +1 ). 


# check v1 leafcutter_regtools vs. v2 leafcutter_regtools


```{r}
#| include: false
suppressMessages(library(tidyverse))
suppressMessages(library(data.table))
suppressMessages(library(glue))
```


```{r}
#| include: false

coord_to_key = function(coord) {
  s = str_split(coord, "\\:|-", simplify = TRUE)
  s = glue("{s[1]}:{str_sub(s[2], 1, 5)}-{str_sub(s[3], 1, 5)}")
  return(s)
}


lgl2int = function(x) {
  # x is like c(T, T, F)
  x = as.integer(x)
  x = paste(x, collapse = "", sep = "")
  x = strtoi(x, base = 2)
}


```

## run1 results - OG script with 0based intron, and 1off bug

```{r}
# classified junctions
jfc1 = fread("./run1/run1_junction_classifications.txt")
cnts1 = fread("./run1/run1_perind.counts.noise_by_intron.gz")

```

```{r}
cnts1[, itype := str_extract(chrom, "\\w+$")]
cnts1[, coord := str_remove(chrom, "\\:\\w+$")]

# jfc1[, key := map_vec(Intron_coord, coord_to_key)]

```



```{r}
head(cnts1)
dim(cnts1)

unique(cnts1$itype)
```


```{r}
cnts1[, .N, by = itype][, .(itype, N, P = N/sum(N))][order(-N)]
```


## run2 results - new script with 1off bug fix

```{r}
# classified junctions
jfc2 = fread("./run2/run2_junction_classifications.txt")
cnts2 = fread("./run2/run2_perind.counts.noise_by_intron.gz")


```

```{r}
cnts2[, itype := str_extract(chrom, "\\w+$")]
cnts2[, coord := str_remove(chrom, "\\:\\w+$")]

```



```{r}
head(cnts2)
dim(cnts2)

unique(cnts2$itype)
```


```{r}
cnts2[, .N, by = itype][, .(itype, N, P = N/sum(N))][order(-N)]
# jfc2[, key := map_vec(Intron_coord, coord_to_key)]
```





## run1 -run2 - compare annot



```{r}
#| column: page
#| include: false
#| eval: false
inner_join(
  jfc1,
  jfc2,
  by = c("Gene_name", "Intron_coord"), suffix = c(".run1", ".run2"),
  multiple = "any"
) %>% head(500) %>% DT::datatable()
```




### Overall differences by category
```{r}
#| echo: false

inner_join(
  cnts1[, .N, by = itype][, .(itype, N, P = N/sum(N))][order(-N)],
  cnts2[, .N, by = itype][, .(itype, N, P = N/sum(N))][order(-N)],
  by = "itype", suffix = c(".run1", ".run2")
) %>% gt::gt()
```



### Check all coordinates are the same



```{r}
c(uniqueN(cnts1$coord), uniqueN(cnts1$coord), nrow(cnts1))
c(uniqueN(cnts2$coord), uniqueN(cnts2$coord), nrow(cnts2))

intersect(cnts1$coord, cnts2$coord) %>% uniqueN()
```


```{r}
checkdf = left_join(
  cnts1[, .(coord, itype)],
  cnts2[, .(coord, itype)],
  by = "coord", suffix = c(".run1", ".run2"),
) %>% 
  mutate(same = itype.run1 == itype.run2) %>% 
  mutate(itype2 = paste0(itype.run1, ",", itype.run2)) 
```

### introns with same classification


```{r}
checkdf[same == TRUE, .N, by = itype2][order(-N)]
# checkdf[same == TRUE]
```


### introns with diff classification



```{r}
checkdf[same == F, .N, by = itype2][order(-N)]
```



# Check v2 Classifier vs. Qn's Classifier results


```{r}
cnts1 = fread("./qn/toy_perind.counts.gz", header = F, col.names = "chrom")
cnts2 = fread("./qn/toyBED_perind.counts.gz", header = F, col.names = "chrom")

cnts1 = separate(cnts1, chrom, c("seqname", "start", "end", "clu"), ":") %>% 
  mutate_at(c("start", "end"), as.integer) %>%
  as.data.table

cnts2 = separate(cnts2, chrom, c("seqname", "start", "end", "clu"), ":") %>% 
  mutate_at(c("start", "end"), as.integer) %>%
  mutate(end2 = end + 1)  %>% 
  as.data.table

```

```{r}

head(cnts1)
dim(cnts1)

head(cnts2)
dim(cnts2)
```


Once converted cnt2 (BED) to leafcutter1 format, the coordinates are exactly the same. 

```{r}
left_join(
  cnts1,
  cnts2[, .(seqname, start, end = end2, clu, toy = "toy")],
  by = c("seqname", "start", "end", "clu"),
  multiple = "any"
  ) %>% 
  .[, .N, by = is.na(toy)]
```

```{r}
jc.q = fread("./qn/FsjcOnLf1_junction_classifications.txt")
jc.v2onBed = fread("./qn/v2onBed_junction_classifications.txt")

```

```{r}

# make jc.v2onBed coordinates the same as jc.q
jc.q = separate(jc.q, Intron_coord, c("chrom", "start", "end")) %>% 
  mutate_at(c("start", "end"), as.integer) %>%
  as.data.table

jc.v2onBed = separate(jc.v2onBed, Intron_coord, c("chrom", "start", "end")) %>% 
  mutate_at(c("start", "end"), as.integer) %>%
  as.data.table %>% 
  .[, .(Gene_name, chrom, start, end = end +1, Annot, Coding, UTR)]
```

```{r}
head(jc.q)
dim(jc.q)

head(jc.v2onBed)
dim(jc.v2onBed)
```



```{r}

jc.q$lab = jc.q[, .(Annot, Coding, UTR)] %>% apply(1, lgl2int)
jc.v2onBed$lab = jc.v2onBed[, .(Annot, Coding, UTR)] %>% apply(1, lgl2int)
```

```{r}
left_join(
  jc.q[, .N, by = .(lab)][, .(lab, N)][order(lab)],
  jc.v2onBed[, .N, by = .(lab)][, .(lab, N)][order(lab)],
  by = "lab",
  suffix = c(".qn", ".v2onBed")
) %>% 
  .[, 
    .(lab, 
      N.qn,
      N.v2onBed,
      P.qn = N.qn/sum(N.qn, na.rm = T),
      P.v2onBed = N.v2onBed/sum(N.v2onBed, na.rm = T),
      diff = abs(N.qn - N.v2onBed)/sum(N.qn, na.rm = T)
    )
  ]

```

### Introns where qn's is 7 and v2onBed is not 
```{r}
left_join(
  jc.q[lab == 7],
  jc.v2onBed,
  by = c("Gene_name", "chrom", "start", "end"),
  suffix = c(".qn", ".v2onBed")
  ) %>% 
  .[, .(lab.qn, lab.v2onBed)] %>% unique
```


### Both version joins completelly on coordinates, so the coordinates are the same. 

```{r}
# join

left_join(
  jc.q[, -(c("Annot", "Coding", "UTR"))], 
  jc.v2onBed[, -(c("Annot", "Coding", "UTR"))],
  by = c("Gene_name", "chrom", "start", "end"),
  suffix = c(".q", ".v2onBed")
  )

left_join(
  jc.q[, -(c("Annot", "Coding", "UTR"))], 
  jc.v2onBed[, -(c("Annot", "Coding", "UTR"))],
  by = c("Gene_name", "chrom", "start", "end"),
  suffix = c(".q", ".v2onBed")
  ) %>% 
  .[is.na(lab.q) | is.na(lab.v2onBed)]



```



### what's the difference in introns in classfications vs. in counts?



```{r}
dim(cnts2)
dim(jc.v2onBed)

head(cnts2)
head(jc.v2onBed)


any(is.na(jc.v2onBed$Gene_name))

```


```{r}
joined1 = full_join(
  cnts2[, .(chrom = seqname, start, end = end2, clu)],
  jc.v2onBed[, .(Gene_name, chrom, start, end, lab)],
  by = c("chrom", "start", "end"),
  )
joined1[sample(1:nrow(joined1),10)]

joined1[, .N, by = .(inSJC = !is.na(Gene_name), inCNT = !is.na(clu))]

```

------------------------------------------------------------

# Check v2 Classifier vs. v3 Classifier

v2 missed a line in parse-annotation func where start coord is converted to 0 based bed. v3 fixed that. Because that cooordinates are only used for ss2gene, and ss2gene is not used in the subsequent functions, this does nto affect the result. 


------------------------------------------------------------


# Check Qns' classifer vs. Qn's Classifier with BED (v2) results


```{r}
jc.q = fread("./qn/FsjcOnLf1_junction_classifications.txt")
jc.q2 = fread("./qn/Fsjc2OnBed_junction_classifications.txt")
```

```{r}

jc.q = separate(jc.q, Intron_coord, c("chrom", "start", "end")) %>% 
  mutate_at(c("start", "end"), as.integer) %>%
  as.data.table

jc.q2 = separate(jc.q2, Intron_coord, c("chrom", "start", "end")) %>% 
  mutate_at(c("start", "end"), as.integer) %>%
  as.data.table %>% 
  .[, .(Gene_name, chrom, start, end, end2 = end +1, Annot, Coding, UTR)]
```

```{r}
head(jc.q)
dim(jc.q)

head(jc.q2)
dim(jc.q2)

```


```{r}
jc.q[, .N, by = .(Annot, Coding, UTR)][, .(Annot, Coding, UTR, N, P = N/sum(N))][order(Annot, Coding, UTR)]


jc.q2[, .N, by = .(Annot, Coding, UTR)][, .(Annot, Coding, UTR, N, P = N/sum(N))][order(Annot, Coding, UTR)]
```



# check v1 leafcutter_regtools vs. v2 updated leafcutter_regtools



## run1 results - OG script with 0based intron, and 1off bug

```{r}
# classified junctions
jfc1 = fread("./run1/run1_junction_classifications.txt")
cnts1 = fread("./run1/run1_perind.counts.noise_by_intron.gz")

```

```{r}
cnts1[, itype := str_extract(chrom, "\\w+$")]
cnts1[, coord := str_remove(chrom, "\\:\\w+$")]

```



```{r}
head(cnts1)
dim(cnts1)

unique(cnts1$itype)
```


```{r}
cnts1[, .N, by = itype][, .(itype, N, P = N/sum(N))][order(-N)]
```


## run3 results - bug fixed plus Quinn's update

```{r}
# classified junctions
jfc3 = fread("./run3/run3_junction_classifications.txt")
cnts3 = fread("./run3/run3_perind.counts.noise_by_intron.gz")


```

```{r}
cnts3[, itype := str_extract(chrom, "\\w+$")]
cnts3[, coord := str_remove(chrom, "\\:\\w+$")]

```



```{r}
head(cnts3)
dim(cnts3)

unique(cnts3$itype)
```


```{r}
cnts3[, .N, by = itype][, .(itype, N, P = N/sum(N))][order(-N)]
# jfc3[, key := map_vec(Intron_coord, coord_to_key)]
```





## run1 -run3 - compare annot



```{r}
#| column: page
#| include: false
#| eval: false
inner_join(
  jfc1,
  jfc3,
  by = c("Gene_name", "Intron_coord"), suffix = c(".run1", ".run3"),
  multiple = "any"
) %>% head(500) %>% DT::datatable()
```




### Overall differences by category
```{r}
#| echo: false

inner_join(
  cnts1[, .N, by = itype][, .(itype, N, P = N/sum(N))][order(-N)],
  cnts3[, .N, by = itype][, .(itype, N, P = N/sum(N))][order(-N)],
  by = "itype", suffix = c(".run1", ".run3")
) %>% gt::gt()
```



### Check all coordinates are the same



```{r}
c(uniqueN(cnts1$coord), uniqueN(cnts1$coord), nrow(cnts1))
c(uniqueN(cnts3$coord), uniqueN(cnts3$coord), nrow(cnts3))

intersect(cnts1$coord, cnts3$coord) %>% uniqueN()
```


```{r}
checkdf = left_join(
  cnts1[, .(coord, itype)],
  cnts3[, .(coord, itype)],
  by = "coord", suffix = c(".run1", ".run3"),
) %>% 
  mutate(same = itype.run1 == itype.run3) %>% 
  mutate(itype3 = paste0(itype.run1, ",", itype.run3)) 
```

### introns with same classification


```{r}
checkdf[same == TRUE, .N, by = itype3][order(-N)]
# checkdf[same == TRUE]
```


### introns with diff classification



```{r}
checkdf[same == F, .N, by = itype3][order(-N)]

```




